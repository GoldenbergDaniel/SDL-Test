  // if (entity->dir.x != 0.0f || entity->dir.y != 0.0f)
  // {
  //   entity->dir = normalize_2f(entity->dir);
  // }

  // // X Acceleration
  // if (entity->dir.x != 0.0f)
  // {
  //   entity->vel.x += PLAYEGL_ACC * dir(entity->dir.x) * dt;
  //   entity->vel.x = clamp(
  //                         entity->vel.x, 
  //                        -entity->speed * abs(entity->dir.x) * dt,
  //                         entity->speed * abs(entity->dir.x) * dt);
  // }
  // else
  // {
  //   entity->vel.x = lerp_1f(entity->vel.x, 0.0f, PLAYEGL_FRIC * dt);
  //   entity->vel.x = to_zero(entity->vel.x, 0.1f);
  // }

  // // Y Acceleration
  // if (entity->dir.y != 0.0f)
  // {
  //   entity->vel.y += PLAYEGL_ACC * dir(entity->dir.y) * dt;
  //   entity->vel.y = clamp(
  //                         entity->vel.y, 
  //                        -entity->speed * abs(entity->dir.y) * dt, 
  //                         entity->speed * abs(entity->dir.y) * dt);
  // }
  // else 
  // {
  //   entity->vel.y = lerp_1f(entity->vel.y, 0.0f, PLAYEGL_FRIC * dt);
  //   entity->vel.y = to_zero(entity->vel.y, 0.1f);
  // }

  // Entity collision detection and resolution
  // for (u8 i = 1; i < game->entity_count; i++)
  // {
  //   if (rect_ranges_intersect(
  //                             player->pos, 
  //                             entities[i].pos, 
  //                             player->width,
  //                             player->height,
  //                             entities[i].width, 
  //                             entities[i].height))
  //   {
  //     // NOTE: Broken!
  //     if (!player->hurt_cooldown.is_running)
  //     {
  //       timegl_start(&player->hurt_cooldown, FALSE);
  //     }
  //     else
  //     {
  //       timegl_tick(&player->hurt_cooldown, game->dt);

  //       if (player->hurt_cooldown.timeout)
  //       {
  //         // printf("Timeout!\n");
  //       }

  //       // printf("Timer: %f\n", player->hurt_cooldown.cugl_duration);
  //     }
  //   }
  // }