RAYCAST

  Collider wall = get_nearest_entity_of_type(game, entity->pos, EntityType_Wall)->col;
  Ray *ray = &entity->ray;
  Vec2F local_pos = V2F_ZERO;
  u16 dist = 1000;
  u8 inc = 1;

  for (u16 i = 0; i < dist; i += inc)
  {
    local_pos.x += inc * cosf(entity->rot * RADIANS);
    local_pos.y += inc * sinf(entity->rot * RADIANS);
    ray->pos = add_2f(local_pos, entity->pos);

    // // Check if ray hit edge of circle
    // if (ray->pos.x >= circle->pos.x - circle->radius &&
    //     ray->pos.x <= circle->pos.x + circle->radius &&
    //     ray->pos.y >= circle->pos.y - circle->radius &&
    //     ray->pos.y <= circle->pos.y + circle->radius)
    // {
    //   printf("Hit! %f, %f!\n", ray->pos.x, ray->pos.y);
    //   break;
    // }
    // else
    // {
    //   printf("No hit.\n");
    // }

    Vec2F p = ray->pos;
    Vec2F v1 = wall.vertices[3];
    Vec2F v2 = wall.vertices[1];

    if ((p.x >= v1.x) && (p.x <= v2.x) && (p.y >= v1.y) && (p.y <= v2.y))
    {
      printf("Hit! %f, %f!\n", ray->pos.x, ray->pos.y);
      break;
    }
    else
    {
      printf("No hit.\n");
    }
  }

PRINT LISTS

#ifdef DEBUG
static
void print_lists(Game *game)
{
  EntityList list = game->entities;

  printf("Arena: ");

  for (Entity *e = list.head; e != NULL; e = e->next)
  {
    printf("%llu -> ", e->id);
  }
  
  printf("NULL\n");

  printf("Freelist: ");

  Entity *curr = list.first_free;
  while (curr)
  {
    printf("%llu -> ", curr->id);
    curr = curr->next_free;
  }

  printf("NULL\n");
  printf("\n");
}
#endif

CONTROLLED FLYING
    case MoveType_Flying:
    {
      f32 omega = clamp(90.0f * magnitude_2f(en->vel), 100.0f, 180.0f);

      if (is_key_pressed(KEY_A)) en->rot += omega * dt;
      if (is_key_pressed(KEY_D)) en->rot -= omega * dt;

      if (is_key_pressed(KEY_W) && !is_key_pressed(KEY_S))
      {
        en->speed = lerp_1f(en->speed, PLAYER_SPEED, PLAYER_ACC * dt);
      }
      else if (!is_key_pressed(KEY_W) && is_key_pressed(KEY_S))
      {
        en->speed = lerp_1f(en->speed, 0.0f, PLAYER_FRIC * 2 * dt);
        en->speed = to_zero(en->speed, 1.0f);
      }
      else
      {
        en->speed = lerp_1f(en->speed, 0.0f, PLAYER_FRIC * dt);
        en->speed = to_zero(en->speed, 1.0f);
      }

      en->vel.x = cosf(en->rot * RADIANS) * en->speed * dt;
      en->vel.y = sinf(en->rot * RADIANS) * en->speed * dt;

      en->dir = scale_2f(en->vel, 1.0f / magnitude_2f(en->vel));
    }


ALTERNATIVE XFORM UPDATE (doesn't quite work)

// void update_entity_xform(Game *game, Entity *en)
// {
//   Mat3x3F xform = m3x3f(1.0f);

//   Vec2F entity_pos = pos_from_entity(en);
//   Vec2F entity_pos_offset = origin_offset_from_entity(en);
//   f32 entity_rot = rot_from_entity(en);
//   Vec2F entity_scale = scale_from_entity(en);
//   bool entity_flip_x = flip_x_from_entity(en);
//   bool entity_flip_y = flip_y_from_entity(en);

//   xform = mul_3x3f(scale_3x3f(entity_scale.x, entity_scale.y), xform);
//   xform = mul_3x3f(translate_3x3f(entity_pos_offset.x, entity_pos_offset.y), xform);

//   if (entity_flip_x)
//   {
//     xform = mul_3x3f(scale_3x3f(-1.0f, 1.0f), xform);
//   }

//   if (entity_flip_y)
//   {
//     xform = mul_3x3f(scale_3x3f(1.0f, -1.0f), xform);
//   }

//   // xform = mul_3x3f(translate_3x3f(en->pos.x, en->pos.y), xform);
//   xform = mul_3x3f(rotate_3x3f(entity_rot * RADIANS), xform);
//   // xform = mul_3x3f(translate_3x3f(-en->pos.x, -en->pos.y), xform);
//   xform = mul_3x3f(translate_3x3f(entity_pos.x, entity_pos.y), xform);

//   xform = mul_3x3f(game->camera, xform);

//   Mat3x3F ortho = orthographic_3x3f(0.0f, WIDTH, 0.0f, HEIGHT);
//   xform = mul_3x3f(ortho, xform);

//   en->xform = xform;
// }