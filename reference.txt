COLLISION??

  // Entity collision detection and resolution
  // for (u8 i = 1; i < game->entity_count; i++)
  // {
  //   if (rect_ranges_intersect(
  //                             player->pos, 
  //                             entities[i].pos, 
  //                             player->width,
  //                             player->height,
  //                             entities[i].width, 
  //                             entities[i].height))
  //   {
  //     // NOTE: Broken!
  //     if (!player->hurt_cooldown.is_running)
  //     {
  //       timegl_start(&player->hurt_cooldown, FALSE);
  //     }
  //     else
  //     {
  //       timegl_tick(&player->hurt_cooldown, game->dt);

  //       if (player->hurt_cooldown.timeout)
  //       {
  //         // printf("Timeout!\n");
  //       }

  //       // printf("Timer: %f\n", player->hurt_cooldown.cugl_duration);
  //     }
  //   }
  // }

RAYCAST

  Collider wall = get_nearest_entity_of_type(game, entity->pos, EntityType_Wall)->col;
  Ray *ray = &entity->ray;
  Vec2F local_pos = V2F_ZERO;
  u16 dist = 1000;
  u8 inc = 1;

  for (u16 i = 0; i < dist; i += inc)
  {
    local_pos.x += inc * cosf(entity->rot * RADIANS);
    local_pos.y += inc * sinf(entity->rot * RADIANS);
    ray->pos = add_2f(local_pos, entity->pos);

    // // Check if ray hit edge of circle
    // if (ray->pos.x >= circle->pos.x - circle->radius &&
    //     ray->pos.x <= circle->pos.x + circle->radius &&
    //     ray->pos.y >= circle->pos.y - circle->radius &&
    //     ray->pos.y <= circle->pos.y + circle->radius)
    // {
    //   printf("Hit! %f, %f!\n", ray->pos.x, ray->pos.y);
    //   break;
    // }
    // else
    // {
    //   printf("No hit.\n");
    // }

    Vec2F p = ray->pos;
    Vec2F v1 = wall.vertices[3];
    Vec2F v2 = wall.vertices[1];

    if ((p.x >= v1.x) && (p.x <= v2.x) && (p.y >= v1.y) && (p.y <= v2.y))
    {
      printf("Hit! %f, %f!\n", ray->pos.x, ray->pos.y);
      break;
    }
    else
    {
      printf("No hit.\n");
    }
  }

PRINT LISTS

#ifdef DEBUG
static
void print_lists(Game *game)
{
  EntityList list = game->entities;

  printf("Arena: ");

  for (Entity *e = list.head; e != NULL; e = e->next)
  {
    printf("%llu -> ", e->id);
  }
  
  printf("NULL\n");

  printf("Freelist: ");

  Entity *curr = list.first_free;
  while (curr)
  {
    printf("%llu -> ", curr->id);
    curr = curr->next_free;
  }

  printf("NULL\n");
  printf("\n");
}
#endif

CONTROLLED FLYING
    case MoveType_Flying:
    {
      f32 omega = clamp(90.0f * magnitude_2f(en->vel), 100.0f, 180.0f);

      if (is_key_pressed(KEY_A)) en->rot += omega * dt;
      if (is_key_pressed(KEY_D)) en->rot -= omega * dt;

      if (is_key_pressed(KEY_W) && !is_key_pressed(KEY_S))
      {
        en->speed = lerp_1f(en->speed, PLAYER_SPEED, PLAYER_ACC * dt);
      }
      else if (!is_key_pressed(KEY_W) && is_key_pressed(KEY_S))
      {
        en->speed = lerp_1f(en->speed, 0.0f, PLAYER_FRIC * 2 * dt);
        en->speed = to_zero(en->speed, 1.0f);
      }
      else
      {
        en->speed = lerp_1f(en->speed, 0.0f, PLAYER_FRIC * dt);
        en->speed = to_zero(en->speed, 1.0f);
      }

      en->vel.x = cosf(en->rot * RADIANS) * en->speed * dt;
      en->vel.y = sinf(en->rot * RADIANS) * en->speed * dt;

      en->dir = scale_2f(en->vel, 1.0f / magnitude_2f(en->vel));
    }